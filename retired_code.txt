import io
from flask import Flask, jsonify, request
from flask_cors import CORS, cross_origin
import jobs
import docker
import tempfile


#-----------------------------v CONFIG v-----------------------------#


app = Flask(__name__)
app.config["JSONIFY_MIMETYPE"] = "application/json"
CORS(app, resources={r"/api/*": {"origins": "*"}})


#-----------------------------v AUX FUNCTIONS v-----------------------------#

"""def build_image():

    dockerfile_content = b'
    # Use a base image that includes MiniZinc
    FROM minizinc/minizinc:latest

    # Create a directory for your MiniZinc application
    WORKDIR /app

    # Copy your MiniZinc model file into the container
    COPY . .

    # Define environment variables for the model string and solver name
    ENV MODEL_STRING=""
    ENV SOLVER_NAME="gecode"

    # Define the command to run your MiniZinc application, using MODEL_STRING
    CMD ["minizinc", "--solver", "$SOLVER_NAME", "$MODEL_STRING"]'

    # Convert the Dockerfile content to a file-like object
    dockerfile_obj = io.BytesIO(dockerfile_content)

    # Create a Docker client
    docker_client = docker.from_env()

    # Build the Docker image from the Dockerfile string
    image, build_logs = docker_client.images.build(
        fileobj=dockerfile_obj,
        rm=True,  # Remove intermediate containers
        tag='minizinc-job-image',
    )

    # Print build logs
    for log_entry in build_logs:
        print(log_entry)"""

#-----------------------------v ROUTES v-----------------------------# 


@app.route("/api", methods=["GET"])
@cross_origin()
def get_api_data():
    return jsonify({"message": "This is the API data. Hello"})


@app.route("/api/solver", methods=["POST"])
@cross_origin()
def solver():
    model_string = request.get_json()["model_string"]
    solver_results = jobs.start_minizinc_job(model_string)
    print("RESPONSE: ", solver_results)
    response = jsonify(solver_results)
    return response


#-----------------------------v INIT v-----------------------------# 


if __name__ == "__main__":
    app.run(host="0.0.0.0", debug=True)







    try {
      // Create a new JSON object containing the MiniZinc model string.
      const jsonData = {
        model_string: modelString,
      };

      // Send a POST request to the /api/solver endpoint with the JSON object as the body of the request.
      const response = await fetch("api/solver", {
        method: "POST",
        headers: new Headers({
          "Content-Type": "application/json",
        }),
        body: JSON.stringify(jsonData),
      });

      // Check if the response was successful.
      if (response.status === 200) {
        // Parse the JSON response to extract the results of the MiniZinc solve.
        const json = await response.json();

        // Update the state variables with the results of the MiniZinc solve.
        setMessage(json.message);
      } else {
        // Handle the error.
        console.error("Error fetching data:", response.statusText);
      }
    } catch (error) {
      // Handle the error.
      console.error("Error fetching data:", error);
    }
  }







    apiVersion: apps/v1
kind: Deployment
metadata:
  name: rabbitmq
spec:
  replicas: 1
  selector:
    matchLabels:
      app: rabbitmq
  template:
    metadata:
      labels:
        app: rabbitmq
    spec:
      containers:
        - name: rabbitmq
          image: bitnami/rabbitmq:latest
          ports:
            - containerPort: 5672
          env:
            - name: RABBITMQ_USERNAME
              value: guest
            - name: RABBITMQ_PASSWORD
              value: guest










apiVersion: v1
kind: Service
metadata:
  name: rabbitmq
spec:
  selector:
    app: rabbitmq
  ports:
    - protocol: TCP
      port: 5672
      targetPort: 5672






# Use a base image that includes MiniZinc
FROM minizinc/minizinc:latest

# Create a directory for your MiniZinc application
WORKDIR /app

# Copy your MiniZinc model file into the container
COPY . .

# Define environment variables for the model string and solver name
ENV MODEL_STRING=""
ENV SOLVER_NAME="gecode"

# Define the command to run your MiniZinc application, using MODEL_STRING
CMD ["minizinc", "--solver", "$SOLVER_NAME", "$MODEL_STRING"]








import os
import tempfile
from kubernetes import client, config
import time
import logging
import uuid

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def start_minizinc_job(model_string, namespace="default"):
    try:
        # Load Kubernetes configuration
        config.load_incluster_config()

        # Create a unique job name
        job_name = f"minizinc-job-{int(time.time())}-{str(uuid.uuid4())[:8]}"

        logger.info(f"Starting Minizinc job with name: {job_name}")

        # Get the current working directory
        current_directory = os.path.dirname(__file__)

        # Create a temporary file with the Minizinc model content in the current directory
        temp_file = tempfile.NamedTemporaryFile(mode='w+', delete=False, suffix=".mzn", dir=current_directory)
        temp_file.write(model_string)
        temp_model_path = temp_file.name

        # Create Minizinc job
        minizinc_job = create_minizinc_job(job_name, model_string)
        batch_api = client.BatchV1Api()
        batch_api.create_namespaced_job(namespace=namespace, body=minizinc_job)

        # Wait for the Minizinc job to complete
        wait_for_job_completion(batch_api, job_name, namespace)

    except Exception as e:
        logger.error(f"An error occurred: {e}")

def create_minizinc_job(job_name, model_string):
    return client.V1Job(
        metadata=client.V1ObjectMeta(name=job_name),
        spec=client.V1JobSpec(
            template=client.V1PodTemplateSpec(
                spec=client.V1PodSpec(
                    containers=[
                        client.V1Container(
                            name="minizinc-containe r",
                            image="minizinc/minizinc:latest",
                            command=["/bin/sh", "-c"],
                            args=[
                                "echo 'Starting Minizinc commands' && echo \"$MODEL_STRING\" > model.mzn && minizinc model.mzn && echo 'Finished Minizinc command'",
                            ],
                            env=[
                                client.V1EnvVar(name="MODEL_STRING", value=model_string),
                            ],
                        )
                    ],
                    restart_policy="OnFailure",
                )
            )
        )
    )

def wait_for_job_completion(api, job_name, namespace):
    while True:
        logger.info(f"Checking status for Minizinc job: {job_name}")
        job_status = api.read_namespaced_job_status(name=job_name, namespace=namespace)
        if job_status.status.succeeded:
            logger.info("Minizinc job completed successfully.")
            break
        elif job_status.status.failed:
            logger.error("Minizinc job failed.")
            break
        else:
            logger.info("Waiting for the Minizinc job to complete...")
            time.sleep(2)



import pika
def main():
    print("STARTING RECEIVE.....")
    connection_params = pika.ConnectionParameters(
        'definition.default.svc.cluster.local', 
        5672, 
        '/', 
        pika.PlainCredentials('default_user_ihJ24uf17gPjMqD-ZW2', 'i_glY8bc4qqzLXp91zWDnclB_aRb7qzf')
    )

    connection = pika.BlockingConnection(connection_params)
    channel = connection.channel()

    channel.queue_declare(queue='hello')


    def callback(ch, method, properties, body):
        print(f" [x] Received {body}")

    channel.basic_consume(queue='hello',
                        auto_ack=True,
                        on_message_callback=callback)

    print(' [*] Waiting for messages. To exit press CTRL+C')
    channel.start_consuming()

import io
from flask import Flask, jsonify, request
from flask_cors import CORS, cross_origin
import jobs
import docker
import tempfile










#!/usr/bin/env python
import os
import pika

def sendHelloWorld():
  rabbitmq_username = os.getenv("RABBITMQ_USERNAME")
  rabbitmq_password = os.getenv("RABBITMQ_PASSWORD")
  print(rabbitmq_username, flush=True)
  print(rabbitmq_password, flush=True)
  connection = pika.BlockingConnection(pika.ConnectionParameters(host='message-broker.default.svc.cluster.local', credentials=pika.PlainCredentials(rabbitmq_username, rabbitmq_password)))
  channel = connection.channel()

  channel.queue_declare(queue='hello')

  channel.basic_publish(exchange='', routing_key='hello', body='Hello World!')
  print(" [x] Sent 'Hello World!'", flush=True)
  connection.close()



